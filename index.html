<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Java-fire by jangasoft</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Java-fire</h1>
        <p>Transactional Java-based Event Processing Framework</p>

        <p class="view"><a href="https://github.com/jangasoft/java-fire">View the Project on GitHub <small>jangasoft/java-fire</small></a></p>


        <ul>
          <li><a href="https://github.com/jangasoft/java-fire/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/jangasoft/java-fire/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/jangasoft/java-fire">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h2>
<a name="overview" class="anchor" href="#overview"><span class="octicon octicon-link"></span></a>Overview</h2>

<p>Java Fire is a event framework and platform, providing:</p>

<ul>
<li>Publish-subscribe: publish (fire) events and have them delivered and processed by registered listeners;</li>
<li>Transactionality: events are fired only within a transaction, and aren't delivered to listeners until the transaction is committed.</li>
</ul><h2>
<a name="obtaining-java-fire" class="anchor" href="#obtaining-java-fire"><span class="octicon octicon-link"></span></a>Obtaining Java Fire</h2>

<p>The current stable release is 1.0.2. Java Fire artefacts are now being hosted at the <a href="http://central.sonatype.org/">Central Repository</a>. The easiest way to obtain it now is to add the corresponding dependencies on your project.</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;cf.janga&lt;/groupId&gt;
  &lt;artifactId&gt;java-fire-core&lt;/artifactId&gt;
  &lt;version&gt;1.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>If you wish to download it manually, you can do so through <a href="https://oss.sonatype.org/content/groups/public/cf/janga/java-fire-core/1.0.2/java-fire-core-1.0.2.jar">here</a>.</p>

<h2>
<a name="using-java-fire" class="anchor" href="#using-java-fire"><span class="octicon octicon-link"></span></a>Using Java Fire</h2>

<h3>
<a name="first-things-first" class="anchor" href="#first-things-first"><span class="octicon octicon-link"></span></a>First Things First</h3>

<p>Before moving on, some basic concepts and terms used throughout this "tutorial".</p>

<ul>
<li>Event: Anything that can be fired, e.g., a particular occurrence in the system;</li>
<li>Handler: Handles fired events. For that, it must be registered against the event types it is interested in. From this point on, we'll use the term process an event to indicate an event being passed on to a handler;</li>
<li>Event Bus: Where events are fired, and eventually delivered to registered handlers;</li>
<li>Transaction: Events can only be fired and delivered to handlers within the scope of a transaction. You can start/commit/rollback a transaction, just like the database ones. Events won't be processed until a transaction is committed.</li>
</ul><p>Most of the programming involved in Java Fire is around annotations. There's simply no interface to implement or abstract class to extend. </p>

<h3>
<a name="defining-events" class="anchor" href="#defining-events"><span class="octicon octicon-link"></span></a>Defining Events</h3>

<p>There are two main annotations for defining events <a href="https://github.com/Event" class="user-mention">@Event</a> and @EventKey. <a href="https://github.com/Event" class="user-mention">@Event</a> is a class-level annotation, and - as the name indicates! - it says that the annotated class is an event type (i.e., things that can be fired through the Event Bus). @EventKey, on the other hand, is a method-level annotation, and it's used to indicate the method from an event type that returns the event key, which is a what differentiates an event from others of the same type. These two annotations are the bare minimum required when defining an event. When a class is annotated with them, we say that it then refers to a valid event type. </p>

<div class="highlight highlight-java"><pre><span class="nd">@Event</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeEvent</span> <span class="o">{</span>
<span class="nd">@EventKey</span>
<span class="kd">public</span> <span class="n">String</span> <span class="nf">getSomeProperty</span><span class="o">()</span> <span class="o">{</span>
<span class="c1">// ...</span>
<span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Event processing in Java Fire - so far - happens only synchronously. This means that, once a transaction is committed, all fired events are processed within the same thread they were fired. Because events aren't processed by registered handlers until the end of a transaction, events representing the same change can be fired. It's because of this that the @EventKey annotation and the duplicateResolution value of the <a href="https://github.com/Event" class="user-mention">@Event</a> annotation exist. Essentially, when two events having the same event key are fired within the same transaction, the value of duplicateResolution will determine which event gets to be processed at the end of the transaction. DuplicateResolution.FIRST_WINS means the first event fired gets to be processed, and all others with the same key will be ignored. DuplicateResolution.LAST_WINS is the opposite, so the last event fired always get to be processed, "overriding" previously fired ones with the same key. </p>

<div class="highlight highlight-java"><pre><span class="nd">@Event</span><span class="o">(</span><span class="n">duplicateResolution</span> <span class="o">=</span> <span class="n">DuplicateResolution</span><span class="o">.</span><span class="na">LAST_WINS</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LastWinsEvent</span> <span class="o">{</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="nd">@Event</span><span class="o">(</span><span class="n">duplicateResolution</span> <span class="o">=</span> <span class="n">DuplicateResolution</span><span class="o">.</span><span class="na">FIRST_WINS</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FirstWinsEvent</span> <span class="o">{</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="defining-handlers" class="anchor" href="#defining-handlers"><span class="octicon octicon-link"></span></a>Defining Handlers</h3>

<p>Unlike events, handlers have no need for class-level annotations. All it's needed is to annotate a method with the <a href="https://github.com/Handle" class="user-mention">@Handle</a> annotation. The only constraints in this sense are that: 1) the method has to be public - duh, 2) the method must return void, and 3) it must take a single argument, whose type is the class of the event that the method is supposed to handle. The class of the parameter has to, obviously, be properly annotated as an event type, or else the framework will throw an error when registering the handler. </p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeEventListener</span> <span class="o">{</span>
<span class="nd">@Handle</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleSomeEvent</span><span class="o">(</span><span class="n">SomeEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// Do your stuff here!</span>
<span class="c1">// ...</span>
<span class="o">}</span>
<span class="c1">// These won't be valid handlers</span>
<span class="nd">@Handle</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleObjectEvent</span><span class="o">(</span><span class="n">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// ...</span>
<span class="o">}</span>
<span class="nd">@Handle</span>
<span class="kd">public</span> <span class="n">String</span> <span class="nf">handleSomeOtherEvent</span><span class="o">(</span><span class="n">SomeOtherEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// ...</span>
<span class="k">return</span> <span class="n">aString</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Handle</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleYetAnotherEvent</span><span class="o">(</span><span class="n">YetAnotherEvent</span> <span class="n">event</span><span class="o">,</span> <span class="n">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// Do your stuff here!</span>
<span class="c1">// ...</span>
<span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="registering-handlers--firing-events" class="anchor" href="#registering-handlers--firing-events"><span class="octicon octicon-link"></span></a>Registering Handlers &amp; Firing Events</h3>

<p>The registration of handlers and firing of events is done through the Event Bus. To fire an event, one simply needs to pass down an instance of the event to be fired. The bus takes care of communicating with the current transaction to get that event processed when the time comes. The event instance provided to the bus must be of a class which is properly annotated as an event type - as discussed above - or else an exception is thrown. </p>

<div class="highlight highlight-java"><pre><span class="n">EventBus</span><span class="o">.</span><span class="na">fire</span><span class="o">(</span><span class="k">new</span> <span class="n">SampleEvent</span><span class="o">(</span><span class="s">"eventkey"</span><span class="o">));</span>
<span class="c1">// This will throw an EventException</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">fire</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">());</span>
</pre></div>

<p>For registering handlers, there are two ways. One can either provide an instance of a class annotated with handler methods, or the class itself. The difference there is that, in the first case, the instance is always used to process the events. This means that, thread-safety is left entirely to implementors. In the second case, on the other hand, a new instance of the class is automatically created by the framework, and then used to process the event. As with the firing of events, attempting to register an object/class not properly annotated as a handler will throw an exception. </p>

<div class="highlight highlight-java"><pre><span class="n">EventBus</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="k">new</span> <span class="n">SomeEventListener</span><span class="o">());</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">SomeEventListener</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// Any of these will throw an EventException</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">());</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">Object</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>

<h3>
<a name="transactions" class="anchor" href="#transactions"><span class="octicon octicon-link"></span></a>Transactions</h3>

<p>As said before, events can only be fired within the scope of a transaction, which means one needs to be started before anything else. There are two ways of doing so. One is manually, via the EventBus. Doing it that way means you receive a reference to the transaction, which you can then use to perform a commit or rollback.</p>

<div class="highlight highlight-java"><pre><span class="n">EventTransaction</span> <span class="n">transaction</span> <span class="o">=</span> <span class="n">EventBus</span><span class="o">.</span><span class="na">startTransaction</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
<span class="c1">// Do stuff...</span>
<span class="o">...</span>
<span class="c1">// Events are now processed and delivered</span>
<span class="c1">// to registered handlers</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// All events fired within the transaction</span>
<span class="c1">// are cleared and nothing gets processed</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>

<p>Another way to get a transaction started is automatically, when the "automatic transaction start" property is set to true - which is the default. What this means is that, whenever an event is fired, if a transaction doesn't exist for the current thread, one will be created and the event then fired. A reference to the transaction, in this case, can be obtained via the EventBus too. </p>

<div class="highlight highlight-java"><pre><span class="k">try</span> <span class="o">{</span>
<span class="c1">// New transaction started automatically</span>
<span class="c1">// here if one doesn't exist for the current</span>
<span class="c1">// thread</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">fire</span><span class="o">(</span><span class="k">new</span> <span class="n">SomeEvent</span><span class="o">());</span>
<span class="c1">// A reference to the current transaction</span>
<span class="c1">// can always be obtained for commits/rollbacks</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">getCurrentTransaction</span><span class="o">().</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">getCurrentTransaction</span><span class="o">().</span><span class="na">rollback</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>

<p>Given the above then, setting the "automatic transaction start" property to false and attempting to fire an event, without having manually started a transaction, will cause an exception to be thrown by the bus.</p>

<div class="highlight highlight-java"><pre><span class="n">EventBus</span><span class="o">.</span><span class="na">setAutomaticTransactionStart</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="k">try</span> <span class="o">{</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">fire</span><span class="o">(</span><span class="k">new</span> <span class="n">SomeEvent</span><span class="o">());</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">getCurrentTransaction</span><span class="o">().</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">EventException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// No transaction started automatically</span>
<span class="c1">// here, so exception will be raised</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
<span class="n">EventBus</span><span class="o">.</span><span class="na">getCurrentTransaction</span><span class="o">().</span><span class="na">rollback</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>

<h2>
<a name="contributing" class="anchor" href="#contributing"><span class="octicon octicon-link"></span></a>Contributing</h2>

<p>The minimum requirements are:</p>

<ul>
<li>Java 6</li>
<li>Maven 3.0.4</li>
</ul><p>Once you've cloned the repository, open a command prompt and run a <code>mvn clean install</code> to make sure you're all sorted. Do your code changes and then submit a patch to any relevant project owner. Once approved, you're free to push.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/jangasoft">jangasoft</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>