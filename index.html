<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Java-fire by jangasoft</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Java-fire</h1>
        <p>Transactional Java-based Event Processing Framework</p>

        <p class="view"><a href="https://github.com/jangasoft/java-fire">View the Project on GitHub <small>jangasoft/java-fire</small></a></p>


        <ul>
          <li><a href="https://github.com/jangasoft/java-fire/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/jangasoft/java-fire/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/jangasoft/java-fire">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h2>
<a name="overview" class="anchor" href="#overview"><span class="octicon octicon-link"></span></a>Overview</h2>

<p>Java Fire is a event framework and platform, providing:</p>

<ul>
<li>Publish-subscribe: publish (fire) events and have them delivered and processed by registered listeners;</li>
<li>Transactionality: events are fired only within a transaction, and aren't delivered to listeners until the transaction is committed.</li>
</ul><p><strong>Latest stable release is 1.0.0. You can download it <a href="https://github.com/jangasoft/java-fire/releases/download/v1.0.0/java-fire-core-1.0.0.jar">here</a>.</strong></p>

<h2>
<a name="first-things-first" class="anchor" href="#first-things-first"><span class="octicon octicon-link"></span></a>First Things First</h2>

<p>Before moving on, some basic concepts and terms used throughout this "tutorial".</p>

<ul>
<li>Event: Anything that can be fired, e.g., a particular occurrence in the system;</li>
<li>Handler: Handles fired events. For that, it must be registered against the event types it is interested in. From this point on, we'll use the term process an event to indicate an event being passed on to a handler;</li>
<li>Event Bus: Where events are fired, and eventually delivered to registered handlers;</li>
<li>Transaction: Events can only be fired and delivered to handlers within the scope of a transaction. You can start/commit/rollback a transaction, just like the database ones. Events won't be processed until a transaction is committed.</li>
</ul><h2>
<a name="hands-on" class="anchor" href="#hands-on"><span class="octicon octicon-link"></span></a>Hands on</h2>

<p>Most of the programming involved in Java Fire is around annotations. There's simply no interface to implement or abstract class to extend. </p>

<h3>
<a name="defining-events" class="anchor" href="#defining-events"><span class="octicon octicon-link"></span></a>Defining Events</h3>

<p>There are two main annotations for defining events <a href="https://github.com/Event" class="user-mention">@Event</a> and @EventKey. <a href="https://github.com/Event" class="user-mention">@Event</a> is a class-level annotation, and - as the name indicates! - it says that the annotated class is an event type (i.e., things that can be fired through the Event Bus). @EventKey, on the other hand, is a method-level annotation, and it's used to indicate the method from an event type that returns the event key, which is a what differentiates an event from others of the same type. These two annotations are the bare minimum required when defining an event. When a class is annotated with them, we say that it then refers to a valid event type. </p>

<pre><code>@Event
public class SomeEvent {
    @EventKey
    public String getSomeProperty() {
        // ...
    }
}
</code></pre>

<p>Events in Java Fire comes - so far - in one flavour, synchronous. This means that, once a transaction is committed, all fired events are processed within the same thread they were fired. A parameter in the <a href="https://github.com/Event" class="user-mention">@Event</a> annotation is used to mark an event as synchronous. This is the default value though, so it doesn't really need to be provided. The code snippet below illustrates that. </p>

<pre><code>// No need to explicitly specify synchronous here, it is the
// default value.
@Event
public class SomeAsynchronousEvent {
        // ...
}

// You can put the type there explicitly, if you like!
@Event(type = EventType.SYNCHRONOUS)
public class AnotherSynchronousEvent {
        // ...
}
</code></pre>

<p>Because events aren't processed by registered handlers until the end of a transaction, events representing the same change can be fired. It's because of this that the @EventKey annotation and the duplicateResolution value of the <a href="https://github.com/Event" class="user-mention">@Event</a> annotation exist. Essentially, when two events having the same event key are fired within the same transaction, the value of duplicateResolution will determine which event gets to be processed at the end of the transaction. DuplicateResolution.FIRST_WINS means the first event fired gets to be processed, and all others with the same key will be ignored. DuplicateResolution.LAST_WINS is the opposite, so the last event fired always get to be processed, "overriding" previously fired ones with the same key. </p>

<pre><code>@Event(duplicateResolution = DuplicateResolution.LAST_WINS)
public class LastWinsEvent {
}
...
@Event(duplicateResolution = DuplicateResolution.FIRST_WINS)
public class FirstWinsEvent {
}
</code></pre>

<h3>
<a name="defining-handlers" class="anchor" href="#defining-handlers"><span class="octicon octicon-link"></span></a>Defining Handlers</h3>

<p>Unlike events, handlers have no need for class-level annotations. All it's needed is to annotate a method with the <a href="https://github.com/Handle" class="user-mention">@Handle</a> annotation. The only constraints in this sense are that: 1) the method has to be public - duh, 2) the method must return void, and 3) it must take a single argument, whose type is the class of the event that the method is supposed to handle. The class of the parameter has to, obviously, be properly annotated as an event type, or else the framework will throw an error when registering the handler. </p>

<pre><code>public class SomeEventListener {
        @Handle
        public void handleSomeEvent(SomeEvent event) {
                // Do your stuff here!
                // ...
        }
        // These won't be valid handlers
        @Handle
        public void handleObjectEvent(Object object) {
                // ...
        }
        @Handle
        public String handleSomeOtherEvent(SomeOtherEvent event) {
                // ...
                return aString;
        }
        @Handle
        public void handleYetAnotherEvent(YetAnotherEvent event, Object object) {
                // Do your stuff here!
                // ...
        }
}
</code></pre>

<h3>
<a name="registering-handlers--firing-events" class="anchor" href="#registering-handlers--firing-events"><span class="octicon octicon-link"></span></a>Registering Handlers &amp; Firing Events</h3>

<p>The registration of handlers and firing of events is done through the Event Bus. To fire an event, one simply needs to pass down an instance of the event to be fired. The bus takes care of communicating with the current transaction to get that event processed when the time comes. The event instance provided to the bus must be of a class which is properly annotated as an event type - as discussed above - or else an exception is thrown. </p>

<pre><code>EventBus.fire(new SampleEvent("eventkey"));

// This will throw an EventException
EventBus.fire(new Object());
</code></pre>

<p>For registering handlers, there are two ways. One can either provide an instance of a class annotated with handler methods, or the class itself. The difference there is that, in the first case, the instance is always used to process the events. This means that, thread-safety is left entirely to implementors. In the second case, on the other hand, a new instance of the class is automatically created by the framework, and then used to process the event. As with the firing of events, attempting to register an object/class not properly annotated as a handler will throw an exception. </p>

<pre><code>EventBus.register(new SomeEventListener());
EventBus.register(SomeEventListener.class);

// Any of these will throw an EventException
EventBus.register(new Object());
EventBus.register(Object.class);
</code></pre>

<h3>
<a name="transactions" class="anchor" href="#transactions"><span class="octicon octicon-link"></span></a>Transactions</h3>

<p>As said before, events can only be fired within the scope of a transaction, which means one needs to be started before anything else. There are two ways of doing so. One is manually, via the EventBus. Doing it that way means you receive a reference to the transaction, which you can then use to perform a commit or rollback.</p>

<pre><code>EventTransaction transaction = EventBus.startTransaction();
try {
    // Do stuff...
    ...
    // Events are now processed and delivered
    // to registered handlers
    transaction.commit();
} catch (Exception e) {
    // All events fired within the transaction
    // are cleared and nothing gets processed
    transaction.rollback();
}
</code></pre>

<p>Another way to get a transaction started is automatically, when the "automatic transaction start" property is set to true - which is the default. What this means is that, whenever an event is fired, if a transaction doesn't exist for the current thread, one will be created and the event then fired. A reference to the transaction, in this case, can be obtained via the EventBus too. </p>

<pre><code>try {
    // New transaction started automatically
    // here if one doesn't exist for the current
    // thread
    EventBus.fire(new SomeEvent());
    // A reference to the current transaction
    // can always be obtained for commits/rollbacks
    EventBus.getCurrentTransaction().commit();
} catch (Exception e) {
    EventBus.getCurrentTransaction().rollback();
}
</code></pre>

<p>Given the above then, setting the "automatic transaction start" property to false and attempting to fire an event, without having manually started a transaction, will cause an exception to be thrown by the bus.</p>

<pre><code>EventBus.setAutomaticTransactionStart(false);
try {
    EventBus.fire(new SomeEvent());
    EventBus.getCurrentTransaction().commit();
} catch (EventException e) {
    // No transaction started automatically
    // here, so exception will be raised
} catch (Exception e) {
    EventBus.getCurrentTransaction().rollback();
}
</code></pre>

<h2>
<a name="binaries" class="anchor" href="#binaries"><span class="octicon octicon-link"></span></a>Binaries</h2>

<p>You can download the binaries from <a href="https://github.com/jangasoft/java-fire/releases">here</a>. The latest stable release is 1.0.0 (release candidate 1), available directly <a href="https://github.com/jangasoft/java-fire/releases/download/v1.0.0/java-fire-core-1.0.0.jar">here</a>. You can also download the source for any of the versions and generate the binaries yourself. The minimum requirements are:</p>

<ul>
<li>Java 6</li>
<li>Maven 3.0.4</li>
</ul><p>Once you've checked out the source code, open a command line prompt and run a <code>mvn clean install</code>. This should get you the binaries and source on you local repository. A <code>mvn deploy</code> should let you deploy to your remote repository.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/jangasoft">jangasoft</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>