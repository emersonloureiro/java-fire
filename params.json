{"name":"Java-fire","tagline":"Transactional Java-based Event Processing Framework","body":"### Overview\r\nJava Fire is a event framework and platform, providing:\r\n* Publish-subscribe: publish (fire) events and have them delivered and processed by registered listeners;\r\n* Transactionality: events are fired only within a transaction, and aren't delivered by listeners until the transaction is committed; \r\n\r\n### First Things First\r\nBefore moving on, some basic concepts and terms used throughout this \"tutorial\".\r\n\r\n* Event: Anything that can be fired, e.g., a particular occurrence in the system;\r\n* Handler: Handles fired events. For that, it must be registered against the event types it is interested in. From this point on, we'll use the term process an event to indicate an event being passed on to a handler;\r\n* Event Bus: Where events are fired, and eventually delivered to registered handlers;\r\n* Transaction: Events can only be fired and delivered to handlers within the scope of a transaction. You can start/commit/rollback a transaction, just like the database ones. Events won't be processed until a transaction is committed.\r\n\r\n### Hands on\r\nMost of the programming involved in Java Fire is around annotations. There's simply no interface to implement or abstract class to extend. \r\n\r\n## Defining Events\r\nThere are two main annotations for defining events @Event and @EventKey. @Event is a class-level annotation, and - as the name indicates! - it says that the annotated class is an event type (i.e., things that can be fired through the Event Bus). @EventKey, on the other hand, is a method-level annotation, and it's used to indicate the method from an event type that returns the event key, which is a what differentiates an event from others of the same type. These two annotations are the bare minimum required when defining an event. When a class is annotated with them, we say that it then refers to a valid event type. \r\n\r\n`@Event\r\npublic class SomeEvent {\r\n        @EventKey\r\n        public String getSomeProperty() {\r\n        // ...\r\n        }\r\n}`\r\n\r\nEvents in Java Fire comes - so far - in one flavour, synchronous. This means that, once a transaction is committed, all fired events are processed within the same thread they were fired. A parameter in the @Event annotation is used to mark an event as synchronous. This is the default value though, so it doesn't really need to be provided. The code snippet below illustrates that. \r\n\r\n`// No need to explicitly specify synchronous here, it is the\r\n// default value.\r\n@Event\r\npublic class SomeAsynchronousEvent {\r\n        // ...\r\n}`\r\n\r\n`// You can put the type there explicitly, if you like!\r\n@Event(type = EventType.SYNCHRONOUS)\r\npublic class AnotherSynchronousEvent {\r\n        // ...\r\n}`\r\n\r\nBecause events aren't processed by registered handlers until the end of a transaction, events representing the same change can be fired. It's because of this that the @EventKey annotation and the duplicateResolution value of the @Event annotation exist. Essentially, when two events having the same event key are fired within the same transaction, the value of duplicateResolution will determine which event gets to be processed at the end of the transaction. DuplicateResolution.FIRST_WINS means the first event fired gets to be processed, and all others with the same key will be ignored. DuplicateResolution.LAST_WINS is the opposite, so the last event fired always get to be processed, \"overriding\" previously fired ones with the same key. \r\n\r\n`@Event(duplicateResolution = DuplicateResolution.LAST_WINS)\r\npublic class LastWinsEvent {\r\n}\r\n...\r\n@Event(duplicateResolution = DuplicateResolution.FIRST_WINS)\r\npublic class FirstWinsEvent {\r\n}`\r\n\r\n## Defining Handlers\r\n\r\nUnlike events, handlers have no need for class-level annotations. All it's needed is to annotate a method with the @Handle annotation. The only constraints in this sense are that: 1) the method has to be public - duh, 2) the method must return void, and 3) it must take a single argument, whose type is the class of the event that the method is supposed to handle. The class of the parameter has to, obviously, be properly annotated as an event type, or else the framework will throw an error when registering the handler. \r\n\r\n`public class SomeEventListener {\r\n        @Handle\r\n        public void handleSomeEvent(SomeEvent event) {\r\n                // Do your stuff here!\r\n                // ...\r\n        }\r\n        // These won't be valid handlers\r\n        @Handle\r\n        public void handleObjectEvent(Object object) {\r\n                // ...\r\n        }\r\n        @Handle\r\n        public String handleSomeOtherEvent(SomeOtherEvent event) {\r\n                // ...\r\n                return aString;\r\n        }\r\n        @Handle\r\n        public void handleYetAnotherEvent(YetAnotherEvent event, Object object) {\r\n                // Do your stuff here!\r\n                // ...\r\n        }\r\n}`\r\n\r\n## Registering Handlers & Firing Events\r\n\r\nThe registration of handlers and firing of events is done through the Event Bus. To fire an event, one simply needs to pass down an instance of the event to be fired. The bus takes care of communicating with the current transaction to get that event processed when the time comes. The event instance provided to the bus must be of a class which is properly annotated as an event type - as discussed above - or else an exception is thrown. \r\n\r\n`EventBus.fire(new SampleEvent(\"eventkey\"));`\r\n\r\n`// This will throw an EventException\r\nEventBus.fire(new Object());`\r\n\r\nFor registering handlers, there are two ways. One can either provide an instance of a class annotated with handler methods, or the class itself. The difference there is that, in the first case, the instance is always used to process the events. This means that, thread-safety is left entirely to implementors. In the second case, on the other hand, a new instance of the class is automatically created by the framework, and then used to process the event. As with the firing of events, attempting to register an object/class not properly annotated as a handler will throw an exception. \r\n\r\n`EventBus.register(new SomeEventListener());\r\nEventBus.register(SomeEventListener.class);`\r\n\r\n`// Any of these will throw an EventException\r\nEventBus.register(new Object());\r\nEventBus.register(Object.class);`\r\n\r\n## Transactions\r\n\r\nAs said before, events can only be fired within the scope of a transaction, which means one needs to be started before anything else. There are two ways of doing so. One is manually, via the EventBus. Doing it that way means you receive a reference to the transaction, which you can then use to perform a commit or rollback.\r\n\r\n`EventTransaction transaction = EventBus.startTransaction();\r\ntry {\r\n    // Do stuff...\r\n    ...\r\n    // Events are now processed and delivered\r\n    // to registered handlers\r\n    transaction.commit();\r\n} catch (Exception e) {\r\n    // All events fired within the transaction\r\n    // are cleared and nothing gets processed\r\n    transaction.rollback();\r\n}`\r\n\r\nAnother way to get a transaction started is automatically, when the \"automatic transaction start\" property is set to true - which is the default. What this means is that, whenever an event is fired, if a transaction doesn't exist for the current thread, one will be created and the event then fired. A reference to the transaction, in this case, can be obtained via the EventBus too. \r\n\r\n`try {\r\n    // New transaction started automatically\r\n    // here if one doesn't exist for the current\r\n    // thread\r\n    EventBus.fire(new SomeEvent());\r\n    // A reference to the current transaction\r\n    // can always be obtained for commits/rollbacks\r\n    EventBus.getCurrentTransaction().commit();\r\n} catch (Exception e) {\r\n    EventBus.getCurrentTransaction().rollback();\r\n}`\r\n\r\nGiven the above then, setting the \"automatic transaction start\" property to false and attempting to fire an event, without having manually started a transaction, will cause an exception to be thrown by the bus.\r\n\r\n`EventBus.setAutomaticTransactionStart(false);\r\ntry {\r\n    EventBus.fire(new SomeEvent());\r\n    EventBus.getCurrentTransaction().commit();\r\n} catch (EventException e) {\r\n    // No transaction started automatically\r\n    // here, so exception will be raised\r\n} catch (Exception e) {\r\n    EventBus.getCurrentTransaction().rollback();\r\n}`","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}